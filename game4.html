<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>팩맨 with 유령 8마리 (움직임 수정)</title>
  <style>
    body { margin: 0; background: black; color: white; font-family: sans-serif; }
    canvas { display: block; margin: auto; background: black; border: 2px solid white; }
    #scoreBox { text-align: center; font-size: 20px; padding: 10px; }
  </style>
</head>
<body>
  <div id="scoreBox">점수: <span id="score">0</span></div>
  <canvas id="gameCanvas" width="600" height="400"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');

    const pacman = {
      x: 100, y: 100, r: 20,
      dir: 0, // 0=오른쪽,1=아래,2=왼쪽,3=위
      speed: 2,
      mouthOpen: true
    };

    const ghostColors = ['red', 'blue', 'green', 'purple', 'orange', 'pink', 'cyan', 'white'];
    const ghosts = ghostColors.map((color, index) => ({
      x: 100 + index * 40,
      y: 200 + (index % 2) * 50,
      r: 20,
      dir: Math.floor(Math.random() * 4),
      speed: 1.5,
      color: color,
      changeDirCooldown: Math.floor(Math.random() * 60)
    }));

    const cookies = [];
    const cookieRadius = 5;
    let score = 0;

    for (let i = 0; i < 30; i++) {
      cookies.push({
        x: Math.random() * (canvas.width - 40) + 20,
        y: Math.random() * (canvas.height - 40) + 20,
        eaten: false
      });
    }

    function drawPacman() {
      const angle = pacman.mouthOpen ? Math.PI / 4 : 0;
      ctx.beginPath();
      ctx.arc(pacman.x, pacman.y, pacman.r, angle + pacman.dir * Math.PI / 2, 2 * Math.PI - angle + pacman.dir * Math.PI / 2);
      ctx.lineTo(pacman.x, pacman.y);
      ctx.fillStyle = 'yellow';
      ctx.fill();
    }

    function drawGhosts() {
      for (const g of ghosts) {
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.r, 0, Math.PI * 2);
        ctx.fillStyle = g.color;
        ctx.fill();
      }
    }

    function drawCookies() {
      ctx.fillStyle = 'white';
      for (const c of cookies) {
        if (!c.eaten) {
          ctx.beginPath();
          ctx.arc(c.x, c.y, cookieRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function moveEntity(entity) {
      switch (entity.dir) {
        case 0: entity.x += entity.speed; break;
        case 1: entity.y += entity.speed; break;
        case 2: entity.x -= entity.speed; break;
        case 3: entity.y -= entity.speed; break;
      }
      if (entity.x > canvas.width) entity.x = 0;
      if (entity.x < 0) entity.x = canvas.width;
      if (entity.y > canvas.height) entity.y = 0;
      if (entity.y < 0) entity.y = canvas.height;
    }

    function eatCookies() {
      for (const c of cookies) {
        const dx = pacman.x - c.x;
        const dy = pacman.y - c.y;
        if (!c.eaten && Math.sqrt(dx * dx + dy * dy) < pacman.r + cookieRadius) {
          c.eaten = true;
          score += 10;
          scoreEl.textContent = score;
        }
      }
    }

    function checkGhostCollision() {
      for (const g of ghosts) {
        const dx = pacman.x - g.x;
        const dy = pacman.y - g.y;
        if (Math.sqrt(dx * dx + dy * dy) < pacman.r + g.r) {
          alert('👻 게임 오버! 점수: ' + score);
          document.location.reload();
        }
      }
    }

    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      moveEntity(pacman);
      eatCookies();
      checkGhostCollision();
      pacman.mouthOpen = !pacman.mouthOpen;

      for (const g of ghosts) {
        if (g.changeDirCooldown <= 0) {
          g.dir = Math.floor(Math.random() * 4);
          g.changeDirCooldown = 60 + Math.floor(Math.random() * 60);
        } else {
          g.changeDirCooldown--;
        }
        moveEntity(g);
      }

      drawCookies();
      drawPacman();
      drawGhosts();
    }

    // 여기서 키 이벤트 제대로 등록하고 방향값 즉시 바꿈
    window.addEventListener('keydown', e => {
      switch(e.key) {
        case 'ArrowRight': pacman.dir = 0; break;
        case 'ArrowDown': pacman.dir = 1; break;
        case 'ArrowLeft': pacman.dir = 2; break;
        case 'ArrowUp': pacman.dir = 3; break;
      }
    });

    setInterval(update, 1000 / 60);
  </script>
</body>
</html>
